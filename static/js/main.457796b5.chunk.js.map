{"version":3,"sources":["Types.ts","models/Piece.ts","models/Position.ts","referee/rules/GeneralRules.ts","referee/rules/KingRules.ts","models/Board.ts","referee/rules/PawnRules.ts","referee/rules/KnightRules.ts","referee/rules/BishopRules.ts","referee/rules/RookRules.ts","referee/rules/QueenRules.ts","models/Pawn.ts","Constants.ts","components/Tile/Tile.tsx","components/Chessboard/Chessboard.tsx","components/Referee/Referee.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["PieceType","TeamType","Piece","position","type","team","hasMoved","possibleMoves","arguments","length","undefined","_classCallCheck","image","this","concat","_createClass","key","get","PAWN","ROOK","KNIGHT","BISHOP","KING","QUEEN","value","otherPiece","samePosition","otherPosition","_this$possibleMoves","clone","map","m","Position","x","y","tileIsOccupied","boardState","find","p","tileIsOccupiedByOpponent","tileIsEmptyOrOccupiedByOpponent","getCastlingMoves","king","boardstate","_step","rooks","filter","isRook","_iterator","_createForOfIteratorHelper","_loop","_rook$possibleMoves","rook","direction","adjacentPosition","some","_step2","conceringTiles","enemyPieces","valid","_iterator2","s","n","done","enemy","_step3","_iterator3","_loop2","move","t","err","e","f","push","Board","pieces","totalTurns","winningTeam","OPPONENT","OUR","_this","piece","getValidMoves","isKing","_toConsumableArray","checkCurrentTeamMoves","currentTeam","_step4","_this2","_iterator4","_step5","_iterator5","simulatedBoard","samePiecePosition","_step6","clonedKing","_iterator6","_loop3","_piece$possibleMoves","_piece$possibleMoves2","isPawn","pawn","specialRow","pawnDirection","normalMove","specialMove","upperLeftAttack","upperRightAttack","leftPosition","rightPosition","leftPiece","enPassant","rightPiece","getPossiblePawnMoves","knight","i","j","verticalMove","horizontalMove","getPossibleKnightMoves","bishop","destination","getPossibleBishopMoves","getPossibleRookMoves","queen","getPossibleQueenMoves","getPossibleKingMoves","enPassantMove","validMove","playedPiece","destinationPiece","newKingXPosition","calculateAllMoves","reduce","results","Math","abs","Pawn","_Piece","_inherits","_super","_createSuper","call","VERTICAL_AXIS","HORIZONTAL_AXIS","GRID_SIZE","initialBoard","Tile","_ref","number","className","highlight","Boolean","join","_jsx","children","style","backgroundImage","Chessboard","playMove","_useState","useState","_useState2","_slicedToArray","activePiece","setActivePiece","_useState3","_useState4","grabPosition","setGrabPosition","chessboardRef","useRef","board","currentPiece","_Fragment","onMouseMove","chessboard","current","minX","offsetLeft","minY","offsetTop","maxX","clientWidth","maxY","clientHeight","clientX","clientY","left","top","movePiece","onMouseDown","element","target","classList","contains","grabX","floor","grabY","ceil","grabPiece","onMouseUp","removeProperty","dropPiece","id","ref","Referee","setBoard","promotionPawn","setPromotionPawn","modalRef","checkmateModalRef","promotePawn","pieceType","_modalRef$current2","previousBoard","clonedBoard","add","promotionTeamType","_jsxs","color","fontSize","textAlign","onClick","src","_checkmateModalRef$cu2","_playedPiece$possible","playedMoveIsValid","initialPosition","desiredPosition","isEnPassantMove","_checkmateModalRef$cu","remove","_modalRef$current","promotionRow","previousPromotionPawn","clonedPlayedPiece","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","React","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.457796b5.chunk.js","sourcesContent":["export enum PieceType {\n    PAWN = 'pawn',\n    BISHOP = 'bishop',\n    KNIGHT = 'knight',\n    ROOK = 'rook',\n    QUEEN = 'queen',\n    KING = 'king',\n}\n\nexport enum TeamType {\n    OPPONENT = 'b',\n    OUR = 'w',\n}","import { TeamType, PieceType } from \"../Types\";\nimport { Position } from \"./Position\";\n\nexport class Piece {\n    image: string;\n    position: Position;\n    type: PieceType;\n    team: TeamType;\n    possibleMoves?: Position[];\n    hasMoved: boolean;\n    constructor(position: Position, type: PieceType,\n        team: TeamType, hasMoved: boolean,\n        possibleMoves: Position[] = []) {\n        this.image = `assets/images/${type}_${team}.png`;\n        this.position = position;\n        this.type = type;\n        this.team = team;\n        this.possibleMoves = possibleMoves;\n        this.hasMoved = hasMoved;\n    }\n\n    get isPawn() : boolean {\n        return this.type === PieceType.PAWN\n    }\n\n    get isRook() : boolean {\n        return this.type === PieceType.ROOK\n    }\n\n    get isKnight() : boolean {\n        return this.type === PieceType.KNIGHT\n    }\n\n    get isBishop() : boolean {\n        return this.type === PieceType.BISHOP\n    }\n\n    get isKing() : boolean {\n        return this.type === PieceType.KING\n    }\n\n    get isQueen() : boolean {\n        return this.type === PieceType.QUEEN\n    }\n\n    samePiecePosition(otherPiece: Piece) : boolean {\n        return this.position.samePosition(otherPiece.position);\n    }\n\n    samePosition(otherPosition: Position) : boolean {\n        return this.position.samePosition(otherPosition);\n    }\n\n    clone(): Piece {\n        return new Piece(this.position.clone(),\n             this.type, this.team, this.hasMoved,\n             this.possibleMoves?.map(m => m.clone()));\n    }\n}","export class Position {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n\n    samePosition(otherPosition: Position): boolean {\n        return this.x === otherPosition.x &&\n            this.y === otherPosition.y;\n    }\n\n    clone(): Position {\n        return new Position(this.x, this.y);\n    }\n}","import { Piece, Position } from \"../../models\";\nimport { TeamType } from \"../../Types\";\n\nexport const tileIsOccupied = (position: Position, boardState: Piece[]): boolean => {\n    const piece = boardState.find((p) => p.samePosition(position));\n\n    if (piece) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\nexport const tileIsOccupiedByOpponent = (\n    position: Position,\n    boardState: Piece[],\n    team: TeamType\n  ): boolean => {\n    const piece = boardState.find(\n      (p) => p.samePosition(position) && p.team !== team\n    );\n\n    if (piece) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  export const tileIsEmptyOrOccupiedByOpponent =(\n    position: Position,\n    boardState: Piece[],\n    team: TeamType\n  ) => {\n    return (\n      !tileIsOccupied(position, boardState) ||\n      tileIsOccupiedByOpponent(position, boardState, team)\n    );\n  }","import { Piece, Position } from \"../../models\";\nimport { TeamType } from \"../../Types\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const kingMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n  for (let i = 1; i < 2; i++) {\n    //Diagonal\n    let multiplierX = (desiredPosition.x < initialPosition.x) ? -1 : (desiredPosition.x > initialPosition.x) ? 1 : 0;\n    let multiplierY = (desiredPosition.y < initialPosition.y) ? -1 : (desiredPosition.y > initialPosition.y) ? 1 : 0;\n\n    let passedPosition = new Position(initialPosition.x + (i * multiplierX), initialPosition.y + (i * multiplierY));\n\n    if (passedPosition.samePosition(desiredPosition)) {\n      if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n        return true;\n      }\n    } else {\n      if (tileIsOccupied(passedPosition, boardState)) {\n        break;\n      }\n    }\n  }\n  return false;\n}\n\nexport const getPossibleKingMoves = (king: Piece, boardstate: Piece[]): Position[] => {\n  const possibleMoves: Position[] = [];\n\n  // Top movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x, king.position.y + i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x, king.position.y - i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Upper right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y + i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y - i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y - i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Top left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y + i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n    \n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  return possibleMoves;\n}\n\n// In this method the enemy moves have already been calculated\nexport const getCastlingMoves = (king: Piece, boardstate: Piece[]): Position[] => {\n  const possibleMoves: Position[] = [];\n\n  if (king.hasMoved) return possibleMoves;\n\n  // We get the rooks from the king's team which haven't moved\n  const rooks = boardstate.filter(p => p.isRook\n    && p.team === king.team && !p.hasMoved);\n\n  // Loop through the rooks\n  for (const rook of rooks) {\n    // Determine if we need to go to the right or the left side\n    const direction = (rook.position.x - king.position.x > 0) ? 1 : -1;\n\n    const adjacentPosition = king.position.clone();\n    adjacentPosition.x += direction;\n\n    if(!rook.possibleMoves?.some(m => m.samePosition(adjacentPosition))) continue;\n\n    // We know that the rook can move to the adjacent side of the king\n\n    const conceringTiles = rook.possibleMoves.filter(m => m.y === king.position.y);\n\n    // Checking if any of the enemy pieces can attack the spaces between\n    // The rook and the king\n    const enemyPieces = boardstate.filter(p => p.team !== king.team);\n\n    let valid = true;\n\n    for(const enemy of enemyPieces) {\n      if(enemy.possibleMoves === undefined) continue;\n\n      for(const move of enemy.possibleMoves) {\n        if(conceringTiles.some(t => t.samePosition(move))) {\n          valid = false;\n        }\n\n        if(!valid)\n          break;\n      }\n\n      if(!valid)\n        break;\n    }\n\n    if(!valid) continue;\n\n    // We now want to add it as a possible move!\n    possibleMoves.push(rook.position.clone());\n  }\n\n\n  return possibleMoves;\n}","import { getPossibleBishopMoves, getPossibleKingMoves, getPossibleKnightMoves, getPossiblePawnMoves, getPossibleQueenMoves, getPossibleRookMoves, getCastlingMoves } from \"../referee/rules\";\nimport { PieceType, TeamType } from \"../Types\";\nimport { Pawn } from \"./Pawn\";\nimport { Piece } from \"./Piece\";\nimport { Position } from \"./Position\";\n\nexport class Board {\n    pieces: Piece[];\n    totalTurns: number;\n    winningTeam?: TeamType;\n\n    constructor(pieces: Piece[], totalTurns: number) {\n        this.pieces = pieces;\n        this.totalTurns = totalTurns;\n    }\n\n    get currentTeam(): TeamType {\n        return this.totalTurns % 2 === 0 ? TeamType.OPPONENT : TeamType.OUR;\n    }\n\n    calculateAllMoves() {\n        // Calculate the moves of all the pieces\n        for (const piece of this.pieces) {\n            piece.possibleMoves = this.getValidMoves(piece, this.pieces)\n        }\n\n        // Calculate castling moves\n        for (const king of this.pieces.filter(p => p.isKing)) {\n            if (king.possibleMoves === undefined) continue;\n\n            king.possibleMoves = [...king.possibleMoves, ...getCastlingMoves(king, this.pieces)];\n        }\n\n        // Check if the current team moves are valid\n        this.checkCurrentTeamMoves();\n\n        // Remove the posibble moves for the team that is not playing\n        for (const piece of\n            this.pieces.filter(p => p.team !== this.currentTeam)) {\n            piece.possibleMoves = [];\n        }\n\n        // Check if the playing team still has moves left\n        // Otherwise, checkmate!\n        if (this.pieces.filter(p => p.team === this.currentTeam)\n            .some(p => p.possibleMoves !== undefined && p.possibleMoves.length > 0)) return;\n\n        this.winningTeam = (this.currentTeam === TeamType.OUR) ? TeamType.OPPONENT : TeamType.OUR;\n    }\n\n    checkCurrentTeamMoves() {\n        // Loop through all the current team's pieces\n        for (const piece of this.pieces.filter(p => p.team === this.currentTeam)) {\n            if (piece.possibleMoves === undefined) continue;\n\n            // Simulate all the piece moves\n            for (const move of piece.possibleMoves) {\n                const simulatedBoard = this.clone();\n\n                // Remove the piece at the destination position\n                simulatedBoard.pieces = simulatedBoard.pieces.filter(p => !p.samePosition(move));\n\n                // Get the piece of the cloned board\n                const clonedPiece = simulatedBoard.pieces.find(p => p.samePiecePosition(piece))!;\n                clonedPiece.position = move.clone();\n\n                // Get the king of the cloned board\n                const clonedKing = simulatedBoard.pieces.find(p => p.isKing && p.team === simulatedBoard.currentTeam)!;\n\n                // Loop through all enemy pieces, update their possible moves\n                // And check if the current team's king will be in danger\n                for (const enemy of simulatedBoard.pieces.filter(p => p.team !== simulatedBoard.currentTeam)) {\n                    enemy.possibleMoves = simulatedBoard.getValidMoves(enemy, simulatedBoard.pieces);\n\n                    if (enemy.isPawn) {\n                        if (enemy.possibleMoves.some(m => m.x !== enemy.position.x\n                            && m.samePosition(clonedKing.position))) {\n                            piece.possibleMoves = piece.possibleMoves?.filter(m => !m.samePosition(move));\n                        }\n                    } else {\n                        if (enemy.possibleMoves.some(m => m.samePosition(clonedKing.position))) {\n                            piece.possibleMoves = piece.possibleMoves?.filter(m => !m.samePosition(move));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    getValidMoves(piece: Piece, boardState: Piece[]): Position[] {\n        switch (piece.type) {\n            case PieceType.PAWN:\n                return getPossiblePawnMoves(piece, boardState);\n            case PieceType.KNIGHT:\n                return getPossibleKnightMoves(piece, boardState);\n            case PieceType.BISHOP:\n                return getPossibleBishopMoves(piece, boardState);\n            case PieceType.ROOK:\n                return getPossibleRookMoves(piece, boardState);\n            case PieceType.QUEEN:\n                return getPossibleQueenMoves(piece, boardState);\n            case PieceType.KING:\n                return getPossibleKingMoves(piece, boardState);\n            default:\n                return [];\n        }\n    }\n\n    playMove(enPassantMove: boolean,\n        validMove: boolean,\n        playedPiece: Piece,\n        destination: Position): boolean {\n        const pawnDirection = playedPiece.team === TeamType.OUR ? 1 : -1;\n        const destinationPiece = this.pieces.find(p => p.samePosition(destination));\n\n        // If the move is a castling move do this\n        if (playedPiece.isKing && destinationPiece?.isRook\n            && destinationPiece.team === playedPiece.team) {\n            const direction = (destinationPiece.position.x - playedPiece.position.x > 0) ? 1 : -1;\n            const newKingXPosition = playedPiece.position.x + direction * 2;\n            this.pieces = this.pieces.map(p => {\n                if (p.samePiecePosition(playedPiece)) {\n                    p.position.x = newKingXPosition;\n                } else if (p.samePiecePosition(destinationPiece)) {\n                    p.position.x = newKingXPosition - direction;\n                }\n\n                return p;\n            });\n\n            this.calculateAllMoves();\n            return true;\n        }\n\n        if (enPassantMove) {\n            this.pieces = this.pieces.reduce((results, piece) => {\n                if (piece.samePiecePosition(playedPiece)) {\n                    if (piece.isPawn)\n                        (piece as Pawn).enPassant = false;\n                    piece.position.x = destination.x;\n                    piece.position.y = destination.y;\n                    piece.hasMoved = true;\n                    results.push(piece);\n                } else if (\n                    !piece.samePosition(new Position(destination.x, destination.y - pawnDirection))\n                ) {\n                    if (piece.isPawn) {\n                        (piece as Pawn).enPassant = false;\n                    }\n                    results.push(piece);\n                }\n\n                return results;\n            }, [] as Piece[]);\n\n            this.calculateAllMoves();\n        } else if (validMove) {\n            //UPDATES THE PIECE POSITION\n            //AND IF A PIECE IS ATTACKED, REMOVES IT\n            this.pieces = this.pieces.reduce((results, piece) => {\n                // Piece that we are currently moving\n                if (piece.samePiecePosition(playedPiece)) {\n                    //SPECIAL MOVE\n                    if (piece.isPawn)\n                        (piece as Pawn).enPassant =\n                            Math.abs(playedPiece.position.y - destination.y) === 2 &&\n                            piece.type === PieceType.PAWN;\n                    piece.position.x = destination.x;\n                    piece.position.y = destination.y;\n                    piece.hasMoved = true;\n                    results.push(piece);\n                } else if (!piece.samePosition(destination)) {\n                    if (piece.isPawn) {\n                        (piece as Pawn).enPassant = false;\n                    }\n                    results.push(piece);\n                }\n\n                // The piece at the destination location\n                // Won't be pushed in the results\n                return results;\n            }, [] as Piece[]);\n\n            this.calculateAllMoves();\n        } else {\n            return false;\n        }\n\n        return true;\n    }\n\n    clone(): Board {\n        return new Board(this.pieces.map(p => p.clone()),\n            this.totalTurns);\n    }\n}","import { TeamType } from \"../../Types\";\nimport { Piece, Position } from \"../../models\";\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nimport { Pawn } from \"../../models/Pawn\";\n\nexport const pawnMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n  const specialRow = team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n  //MOVEMENT LOGIC\n  if (\n    initialPosition.x === desiredPosition.x &&\n    initialPosition.y === specialRow &&\n    desiredPosition.y - initialPosition.y === 2 * pawnDirection\n  ) {\n    if (\n      !tileIsOccupied(desiredPosition, boardState) &&\n      !tileIsOccupied(\n        new Position(desiredPosition.x, desiredPosition.y - pawnDirection),\n        boardState\n      )\n    ) {\n      return true;\n    }\n  } else if (\n    initialPosition.x === desiredPosition.x &&\n    desiredPosition.y - initialPosition.y === pawnDirection\n  ) {\n    if (!tileIsOccupied(desiredPosition, boardState)) {\n      return true;\n    }\n  }\n  //ATTACK LOGIC\n  else if (\n    desiredPosition.x - initialPosition.x === -1 &&\n    desiredPosition.y - initialPosition.y === pawnDirection\n  ) {\n    //ATTACK IN UPPER OR BOTTOM LEFT CORNER\n    if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n      return true;\n    }\n  } else if (\n    desiredPosition.x - initialPosition.x === 1 &&\n    desiredPosition.y - initialPosition.y === pawnDirection\n  ) {\n    //ATTACK IN THE UPPER OR BOTTOM RIGHT CORNER\n    if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport const getPossiblePawnMoves = (pawn: Piece, boardState: Piece[]): Position[] => {\n  const possibleMoves: Position[] = [];\n\n  const specialRow = pawn.team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = pawn.team === TeamType.OUR ? 1 : -1;\n\n  const normalMove = new Position(pawn.position.x, pawn.position.y + pawnDirection);\n  const specialMove = new Position(normalMove.x, normalMove.y + pawnDirection);\n  const upperLeftAttack = new Position(pawn.position.x - 1, pawn.position.y + pawnDirection);\n  const upperRightAttack = new Position(pawn.position.x + 1, pawn.position.y + pawnDirection);\n  const leftPosition = new Position(pawn.position.x - 1, pawn.position.y);\n  const rightPosition = new Position(pawn.position.x + 1, pawn.position.y);\n\n  if (!tileIsOccupied(normalMove, boardState)) {\n    possibleMoves.push(normalMove);\n\n    if (pawn.position.y === specialRow &&\n      !tileIsOccupied(specialMove, boardState)) {\n      possibleMoves.push(specialMove)\n    }\n  }\n\n  if (tileIsOccupiedByOpponent(upperLeftAttack, boardState, pawn.team)) {\n    possibleMoves.push(upperLeftAttack);\n  } else if (!tileIsOccupied(upperLeftAttack, boardState)) {\n    const leftPiece = boardState.find(p => p.samePosition(leftPosition));\n    if (leftPiece != null && (leftPiece as Pawn).enPassant) {\n      possibleMoves.push(upperLeftAttack);\n    }\n  }\n\n  if (tileIsOccupiedByOpponent(upperRightAttack, boardState, pawn.team)) {\n    possibleMoves.push(upperRightAttack);\n  } else if (!tileIsOccupied(upperRightAttack, boardState)) {\n    const rightPiece = boardState.find(p => p.samePosition(rightPosition));\n    if (rightPiece != null && (rightPiece as Pawn).enPassant) {\n      possibleMoves.push(upperRightAttack);\n    }\n  }\n\n  return possibleMoves;\n}","import { Piece, Position } from \"../../models\";\nimport { TeamType } from \"../../Types\";\nimport { tileIsEmptyOrOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const knightMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      //TOP AND BOTTOM SIDE MOVEMENT\n      if (desiredPosition.y - initialPosition.y === 2 * i) {\n        if (desiredPosition.x - initialPosition.x === j) {\n          if (\n            tileIsEmptyOrOccupiedByOpponent(\n              desiredPosition,\n              boardState,\n              team\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n\n      //RIGHT AND LEFT SIDE MOVEMENT\n      if (desiredPosition.x - initialPosition.x === 2 * i) {\n        if (desiredPosition.y - initialPosition.y === j) {\n          if (\n            tileIsEmptyOrOccupiedByOpponent(\n              desiredPosition,\n              boardState,\n              team\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\nexport const getPossibleKnightMoves = (knight: Piece, boardstate: Piece[]): Position[] => {\n  const possibleMoves: Position[] = [];\n\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      const verticalMove = new Position(knight.position.x + j, knight.position.y + i * 2);\n      const horizontalMove = new Position(knight.position.x + i * 2, knight.position.y + j);\n\n      if(tileIsEmptyOrOccupiedByOpponent(verticalMove, boardstate, knight.team)) {\n        possibleMoves.push(verticalMove);\n      }\n\n      if(tileIsEmptyOrOccupiedByOpponent(horizontalMove, boardstate, knight.team)) {\n        possibleMoves.push(horizontalMove);\n      }\n    }\n  }\n\n  return possibleMoves;\n}","import { Piece, Position } from \"../../models\";\nimport { TeamType } from \"../../Types\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const bishopMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n    for(let i = 1; i < 8; i++) {\n      //Up right movement\n      if(desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n        let passedPosition = new Position(initialPosition.x + i, initialPosition.y + i);\n        //Check if the tile is the destination tile\n        if(passedPosition.samePosition(desiredPosition)) {\n          //Dealing with destination tile\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          //Dealing with passing tile\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n        \n      //Bottom right movement\n      if(desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n        let passedPosition = new Position(initialPosition.x + i, initialPosition.y - i);\n        //Check if the tile is the destination tile\n        if(passedPosition.samePosition(desiredPosition)) {\n          //Dealing with destination tile\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n\n      //Bottom left movement\n      if(desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n        let passedPosition = new Position(initialPosition.x - i, initialPosition.y - i);\n        //Check if the tile is the destination tile\n        if(passedPosition.samePosition(desiredPosition)) {\n          //Dealing with destination tile\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n\n      //Top left movement\n      if(desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n        let passedPosition = new Position(initialPosition.x - i, initialPosition.y+i);\n        //Check if the tile is the destination tile\n        if(passedPosition.samePosition(desiredPosition)) {\n          //Dealing with destination tile\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  export const getPossibleBishopMoves = (bishop: Piece, boardstate: Piece[]): Position[] => {\n    const possibleMoves: Position[] = [];\n\n    // Upper right movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(bishop.position.x + i, bishop.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom right movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(bishop.position.x + i, bishop.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom left movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(bishop.position.x - i, bishop.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Top left movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(bishop.position.x - i, bishop.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return possibleMoves;\n  }","import { TeamType } from \"../../Types\";\nimport { Piece, Position } from \"../../models\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const rookMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n    if(initialPosition.x === desiredPosition.x) {\n      for(let i = 1; i < 8; i++) {\n        let multiplier = (desiredPosition.y < initialPosition.y) ? -1 : 1;\n\n        let passedPosition = new Position(initialPosition.x, initialPosition.y + (i * multiplier));\n        if(passedPosition.samePosition(desiredPosition)) {\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n    }\n\n    if(initialPosition.y === desiredPosition.y) {\n      for(let i = 1; i < 8; i++) {\n        let multiplier = (desiredPosition.x < initialPosition.x) ? -1 : 1;\n\n        let passedPosition = new Position(initialPosition.x + (i * multiplier), initialPosition.y);\n        if(passedPosition.samePosition(desiredPosition)) {\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  export const getPossibleRookMoves = (rook: Piece, boardstate: Piece[]): Position[] => {\n    const possibleMoves: Position[] = [];\n\n    // Top movement\n    for(let i = 1; i < 8; i++) {\n      // Stop checking if move is outside of the board\n      if(rook.position.y + i > 7) break;\n      const destination = new Position(rook.position.x, rook.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom movement\n    for(let i = 1; i < 8; i++) {\n      // Stop checking if move is outside of the board\n      if(rook.position.y - i < 0) break;\n\n      const destination = new Position(rook.position.x, rook.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Left movement\n    for(let i = 1; i < 8; i++) {\n      // Stop checking if move is outside of the board\n      if(rook.position.x - i < 0) break;\n\n      const destination = new Position(rook.position.x - i, rook.position.y);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Right movement\n    for(let i = 1; i < 8; i++) {\n      // Stop checking if move is outside of the board\n      if(rook.position.x + i > 7) break;\n\n      const destination = new Position(rook.position.x + i, rook.position.y);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return possibleMoves;\n  }","import { TeamType } from \"../../Types\";\nimport { Piece, Position } from \"../../models\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const queenMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n    for(let i = 1; i < 8; i++) {\n      //Diagonal\n      let multiplierX = (desiredPosition.x < initialPosition.x) ? -1 : (desiredPosition.x > initialPosition.x) ? 1 : 0;\n      let multiplierY = (desiredPosition.y < initialPosition.y) ? -1 : (desiredPosition.y > initialPosition.y) ? 1 : 0;\n\n      let passedPosition = new Position(initialPosition.x + (i * multiplierX), initialPosition.y + (i * multiplierY));\n\n      if(passedPosition.samePosition(desiredPosition)) {\n        if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true;\n        }\n      } else {\n        if(tileIsOccupied(passedPosition, boardState)) {\n          break;\n        }\n      }\n    }\n    return false;\n  }\n\n  export const getPossibleQueenMoves = (queen: Piece, boardstate: Piece[]): Position[] => {\n    const possibleMoves: Position[] = [];\n\n    // Top movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x, queen.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x, queen.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Left movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x - i, queen.position.y);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Right movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x + i, queen.position.y);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Upper right movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x + i, queen.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom right movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x + i, queen.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom left movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x - i, queen.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Top left movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x - i, queen.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return possibleMoves;\n  }","import { PieceType, TeamType } from \"../Types\";\nimport { Piece } from \"./Piece\";\nimport { Position } from \"./Position\";\n\nexport class Pawn extends Piece {\n    enPassant?: boolean;\n    constructor(position: Position, \n        team: TeamType, hasMoved: boolean,\n        enPassant?: boolean,\n        possibleMoves: Position[] = []) {\n        super(position, PieceType.PAWN, team, hasMoved, possibleMoves);\n        this.enPassant = enPassant;\n    }\n\n    clone(): Pawn {\n        return new Pawn(this.position.clone(),\n         this.team, this.hasMoved, this.enPassant, this.possibleMoves?.map(m => m.clone()))\n    }\n}","import { Board } from \"./models/Board\";\nimport { Pawn } from \"./models/Pawn\";\nimport { Piece } from \"./models/Piece\";\nimport { Position } from \"./models/Position\";\nimport { PieceType, TeamType } from \"./Types\";\n\nexport const VERTICAL_AXIS = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"];\nexport const HORIZONTAL_AXIS = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"];\n\nexport const GRID_SIZE = 100;\n\nexport const initialBoard: Board = new Board([\n  new Piece(\n  new Position(0, 7), \n  PieceType.ROOK, \n  TeamType.OPPONENT,\n  false),\n  new Piece(\n  new Position(1, 7),\n  PieceType.KNIGHT,\n  TeamType.OPPONENT,\n  false),\n  new Piece(\n  new Position(2, 7),\n  PieceType.BISHOP,\n  TeamType.OPPONENT,\n  false),\n  new Piece(\n  new Position(3, 7),\n  PieceType.QUEEN,\n  TeamType.OPPONENT,\n  false),\n  new Piece(\n  new Position(4, 7),\n  PieceType.KING,\n  TeamType.OPPONENT,\n  false),\n  new Piece(\n  new Position(5, 7),\n  PieceType.BISHOP,\n  TeamType.OPPONENT,\n  false),\n  new Piece(\n  new Position(6, 7),\n  PieceType.KNIGHT,\n  TeamType.OPPONENT,\n  false),\n  new Piece(\n  new Position(7, 7),\n  PieceType.ROOK,\n  TeamType.OPPONENT,\n  false),\n  new Pawn(\n  new Position(0, 6),\n  TeamType.OPPONENT,\n  false),\n  new Pawn(\n  new Position(1, 6),\n  TeamType.OPPONENT,\n  false),\n  new Pawn(\n  new Position(2, 6),\n  TeamType.OPPONENT,\n  false),\n  new Pawn(\n  new Position(3, 6),\n  TeamType.OPPONENT,\n  false),\n  new Pawn(\n  new Position(4, 6),\n  TeamType.OPPONENT,\n  false),\n  new Pawn(\n  new Position(5, 6),\n  TeamType.OPPONENT,\n  false),\n  new Pawn(\n  new Position(6, 6),\n  TeamType.OPPONENT,\n  false),\n  new Pawn(\n  new Position(7, 6),\n  TeamType.OPPONENT,\n  false),\n\n  new Piece( \n  new Position(0, 0), \n  PieceType.ROOK, \n  TeamType.OUR,\n  false),\n  new Piece(\n  new Position(1, 0),\n  PieceType.KNIGHT,\n  TeamType.OUR,\n  false),\n  new Piece(\n  new Position(2, 0),\n  PieceType.BISHOP,\n  TeamType.OUR,\n  false),\n  new Piece(\n  new Position(3, 0),\n  PieceType.QUEEN,\n  TeamType.OUR,\n  false),\n  new Piece(\n  new Position(4, 0),\n  PieceType.KING,\n  TeamType.OUR,\n  false),\n  new Piece(\n  new Position(5, 0),\n  PieceType.BISHOP,\n  TeamType.OUR,\n  false),\n  new Piece(\n  new Position(6, 0),\n  PieceType.KNIGHT,\n  TeamType.OUR,\n  false),\n  new Piece(\n  new Position(7, 0),\n  PieceType.ROOK,\n  TeamType.OUR,\n  false),\n  new Pawn(\n  new Position(0, 1),\n  TeamType.OUR,\n  false),\n  new Pawn(\n  new Position(1, 1),\n  TeamType.OUR,\n  false),\n  new Pawn(\n  new Position(2, 1),\n  TeamType.OUR,\n  false),\n  new Pawn(\n  new Position(3, 1),\n  TeamType.OUR,\n  false),\n  new Pawn(\n  new Position(4, 1),\n  TeamType.OUR,\n  false),\n  new Pawn(\n  new Position(5, 1),\n  TeamType.OUR,\n  false),\n  new Pawn(\n  new Position(6, 1),\n  TeamType.OUR,\n  false),\n  new Pawn(\n  new Position(7, 1),\n  TeamType.OUR,\n  false),\n], 1);\n\ninitialBoard.calculateAllMoves();","import \"./Tile.css\";\n\ninterface Props {\n  image?: string;\n  number: number;\n  highlight: boolean;\n}\n\nexport default function Tile({ number, image, highlight }: Props) {\n  const className: string = [\"tile\",\n    number % 2 === 0 && \"black-tile\",\n    number % 2 !== 0 && \"white-tile\",\n    highlight && \"tile-highlight\",\n    image && \"chess-piece-tile\"].filter(Boolean).join(' ');\n\n\n  return (\n    <div className={className}>\n      {image && <div style={{ backgroundImage: `url(${image})` }} className=\"chess-piece\"></div>}\n    </div>\n  );\n}","import { useRef, useState } from \"react\";\nimport \"./Chessboard.css\";\nimport Tile from \"../Tile/Tile\";\nimport {\n  VERTICAL_AXIS,\n  HORIZONTAL_AXIS,\n  GRID_SIZE,\n} from \"../../Constants\";\nimport { Piece, Position } from \"../../models\";\n\ninterface Props {\n  playMove: (piece: Piece, position: Position) => boolean;\n  pieces: Piece[];\n}\n\nexport default function Chessboard({playMove, pieces} : Props) {\n  const [activePiece, setActivePiece] = useState<HTMLElement | null>(null);\n  const [grabPosition, setGrabPosition] = useState<Position>(new Position(-1, -1));\n  const chessboardRef = useRef<HTMLDivElement>(null);\n\n  function grabPiece(e: React.MouseEvent) {\n    const element = e.target as HTMLElement;\n    const chessboard = chessboardRef.current;\n    if (element.classList.contains(\"chess-piece\") && chessboard) {\n      const grabX = Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE);\n      const grabY = Math.abs(\n        Math.ceil((e.clientY - chessboard.offsetTop - 800) / GRID_SIZE)\n      );\n      setGrabPosition(new Position(grabX, grabY));\n\n      const x = e.clientX - GRID_SIZE / 2;\n      const y = e.clientY - GRID_SIZE / 2;\n      element.style.position = \"absolute\";\n      element.style.left = `${x}px`;\n      element.style.top = `${y}px`;\n\n      setActivePiece(element);\n    }\n  }\n\n  function movePiece(e: React.MouseEvent) {\n    const chessboard = chessboardRef.current;\n    if (activePiece && chessboard) {\n      const minX = chessboard.offsetLeft - 25;\n      const minY = chessboard.offsetTop - 25;\n      const maxX = chessboard.offsetLeft + chessboard.clientWidth - 75;\n      const maxY = chessboard.offsetTop + chessboard.clientHeight - 75;\n      const x = e.clientX - 50;\n      const y = e.clientY - 50;\n      activePiece.style.position = \"absolute\";\n\n      //If x is smaller than minimum amount\n      if (x < minX) {\n        activePiece.style.left = `${minX}px`;\n      }\n      //If x is bigger than maximum amount\n      else if (x > maxX) {\n        activePiece.style.left = `${maxX}px`;\n      }\n      //If x is in the constraints\n      else {\n        activePiece.style.left = `${x}px`;\n      }\n\n      //If y is smaller than minimum amount\n      if (y < minY) {\n        activePiece.style.top = `${minY}px`;\n      }\n      //If y is bigger than maximum amount\n      else if (y > maxY) {\n        activePiece.style.top = `${maxY}px`;\n      }\n      //If y is in the constraints\n      else {\n        activePiece.style.top = `${y}px`;\n      }\n    }\n  }\n\n  function dropPiece(e: React.MouseEvent) {\n    const chessboard = chessboardRef.current;\n    if (activePiece && chessboard) {\n      const x = Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE);\n      const y = Math.abs(\n        Math.ceil((e.clientY - chessboard.offsetTop - 800) / GRID_SIZE)\n      );\n\n      const currentPiece = pieces.find((p) =>\n        p.samePosition(grabPosition)\n      );\n\n      if (currentPiece) {\n        var succes = playMove(currentPiece.clone(), new Position(x, y));\n\n        if(!succes) {\n          //RESETS THE PIECE POSITION\n          activePiece.style.position = \"relative\";\n          activePiece.style.removeProperty(\"top\");\n          activePiece.style.removeProperty(\"left\");\n        }\n      }\n      setActivePiece(null);\n    }\n  }\n\n  let board = [];\n\n  for (let j = VERTICAL_AXIS.length - 1; j >= 0; j--) {\n    for (let i = 0; i < HORIZONTAL_AXIS.length; i++) {\n      const number = j + i + 2;\n      const piece = pieces.find((p) =>\n        p.samePosition(new Position(i, j))\n      );\n      let image = piece ? piece.image : undefined;\n\n      let currentPiece = activePiece != null ? pieces.find(p => p.samePosition(grabPosition)) : undefined;\n      let highlight = currentPiece?.possibleMoves ? \n      currentPiece.possibleMoves.some(p => p.samePosition(new Position(i, j))) : false;\n\n      board.push(<Tile key={`${j},${i}`} image={image} number={number} highlight={highlight} />);\n    }\n  }\n\n  return (\n    <>\n      <div\n        onMouseMove={(e) => movePiece(e)}\n        onMouseDown={(e) => grabPiece(e)}\n        onMouseUp={(e) => dropPiece(e)}\n        id=\"chessboard\"\n        ref={chessboardRef}\n      >\n        {board}\n      </div>\n    </>\n  );\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport { initialBoard } from \"../../Constants\";\nimport { Piece, Position } from \"../../models\";\nimport { Board } from \"../../models/Board\";\nimport { Pawn } from \"../../models/Pawn\";\nimport { bishopMove, getPossibleBishopMoves, getPossibleKingMoves, getPossibleKnightMoves, getPossiblePawnMoves, getPossibleQueenMoves, getPossibleRookMoves, kingMove, knightMove, pawnMove, queenMove, rookMove } from \"../../referee/rules\";\nimport { PieceType, TeamType } from \"../../Types\";\nimport Chessboard from \"../Chessboard/Chessboard\";\n\nexport default function Referee() {\n    const [board, setBoard] = useState<Board>(initialBoard.clone());\n    const [promotionPawn, setPromotionPawn] = useState<Piece>();\n    const modalRef = useRef<HTMLDivElement>(null);\n    const checkmateModalRef = useRef<HTMLDivElement>(null);\n\n    function playMove(playedPiece: Piece, destination: Position): boolean {\n        // If the playing piece doesn't have any moves return\n        if (playedPiece.possibleMoves === undefined) return false;\n\n        // Prevent the inactive team from playing\n        if (playedPiece.team === TeamType.OUR\n            && board.totalTurns % 2 !== 1) return false;\n        if (playedPiece.team === TeamType.OPPONENT\n            && board.totalTurns % 2 !== 0) return false;\n\n        let playedMoveIsValid = false;\n\n        const validMove = playedPiece.possibleMoves?.some(m => m.samePosition(destination));\n\n        if (!validMove) return false;\n\n        const enPassantMove = isEnPassantMove(\n            playedPiece.position,\n            destination,\n            playedPiece.type,\n            playedPiece.team\n        );\n\n        // playMove modifies the board thus we\n        // need to call setBoard\n        setBoard(() => {\n            const clonedBoard = board.clone();\n            clonedBoard.totalTurns += 1;\n            // Playing the move\n            playedMoveIsValid = clonedBoard.playMove(enPassantMove,\n                validMove, playedPiece,\n                destination);\n\n            if(clonedBoard.winningTeam !== undefined) {\n                checkmateModalRef.current?.classList.remove(\"hidden\");\n            }\n\n            return clonedBoard;\n        })\n\n        // This is for promoting a pawn\n        let promotionRow = (playedPiece.team === TeamType.OUR) ? 7 : 0;\n\n        if (destination.y === promotionRow && playedPiece.isPawn) {\n            modalRef.current?.classList.remove(\"hidden\");\n            setPromotionPawn((previousPromotionPawn) => {\n                const clonedPlayedPiece = playedPiece.clone();\n                clonedPlayedPiece.position = destination.clone();\n                return clonedPlayedPiece;\n            });\n        }\n\n        return playedMoveIsValid;\n    }\n\n    function isEnPassantMove(\n        initialPosition: Position,\n        desiredPosition: Position,\n        type: PieceType,\n        team: TeamType\n    ) {\n        const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n        if (type === PieceType.PAWN) {\n            if (\n                (desiredPosition.x - initialPosition.x === -1 ||\n                    desiredPosition.x - initialPosition.x === 1) &&\n                desiredPosition.y - initialPosition.y === pawnDirection\n            ) {\n                const piece = board.pieces.find(\n                    (p) =>\n                        p.position.x === desiredPosition.x &&\n                        p.position.y === desiredPosition.y - pawnDirection &&\n                        p.isPawn &&\n                        (p as Pawn).enPassant\n                );\n                if (piece) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    //TODO\n    //Add stalemate!\n    function isValidMove(initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType) {\n        let validMove = false;\n        switch (type) {\n            case PieceType.PAWN:\n                validMove = pawnMove(initialPosition, desiredPosition, team, board.pieces);\n                break;\n            case PieceType.KNIGHT:\n                validMove = knightMove(initialPosition, desiredPosition, team, board.pieces);\n                break;\n            case PieceType.BISHOP:\n                validMove = bishopMove(initialPosition, desiredPosition, team, board.pieces);\n                break;\n            case PieceType.ROOK:\n                validMove = rookMove(initialPosition, desiredPosition, team, board.pieces);\n                break;\n            case PieceType.QUEEN:\n                validMove = queenMove(initialPosition, desiredPosition, team, board.pieces);\n                break;\n            case PieceType.KING:\n                validMove = kingMove(initialPosition, desiredPosition, team, board.pieces);\n        }\n\n        return validMove;\n    }\n\n    function promotePawn(pieceType: PieceType) {\n        if (promotionPawn === undefined) {\n            return;\n        }\n\n        setBoard((previousBoard) => {\n            const clonedBoard = board.clone();\n            clonedBoard.pieces = clonedBoard.pieces.reduce((results, piece) => {\n                if (piece.samePiecePosition(promotionPawn)) {\n                    results.push(new Piece(piece.position.clone(), pieceType,\n                        piece.team, true));\n                } else {\n                    results.push(piece);\n                }\n                return results;\n            }, [] as Piece[]);\n\n            clonedBoard.calculateAllMoves();\n\n            return clonedBoard;\n        })\n\n        modalRef.current?.classList.add(\"hidden\");\n    }\n\n    function promotionTeamType() {\n        return (promotionPawn?.team === TeamType.OUR) ? \"w\" : \"b\";\n    }\n    \n    function restartGame() {\n        checkmateModalRef.current?.classList.add(\"hidden\");\n        setBoard(initialBoard.clone());\n    }\n\n    return (\n        <>\n            <p style={{ color: \"white\", fontSize: \"24px\", textAlign: \"center\" }}>Total turns: {board.totalTurns}</p>\n            <div className=\"modal hidden\" ref={modalRef}>\n                <div className=\"modal-body\">\n                    <img onClick={() => promotePawn(PieceType.ROOK)} src={`/assets/images/rook_${promotionTeamType()}.png`} />\n                    <img onClick={() => promotePawn(PieceType.BISHOP)} src={`/assets/images/bishop_${promotionTeamType()}.png`} />\n                    <img onClick={() => promotePawn(PieceType.KNIGHT)} src={`/assets/images/knight_${promotionTeamType()}.png`} />\n                    <img onClick={() => promotePawn(PieceType.QUEEN)} src={`/assets/images/queen_${promotionTeamType()}.png`} />\n                </div>\n            </div>\n            <div className=\"modal hidden\" ref={checkmateModalRef}>\n                <div className=\"modal-body\">\n                    <div className=\"checkmate-body\">\n                        <span>The winning team is {board.winningTeam === TeamType.OUR ? \"white\" : \"black\"}!</span>\n                        <button onClick={restartGame}>Play again</button>\n                    </div>\n                </div>\n            </div>\n            <Chessboard playMove={playMove}\n                pieces={board.pieces} />\n        </>\n    )\n}","import './App.css';\nimport Referee from './components/Referee/Referee';\n\nfunction App() {\n  return (\n    <div id=\"app\">\n      <Referee/>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}